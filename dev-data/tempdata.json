[
  {
    "authorID": 1,
    "title": "Minimum Stack",
    "description": "In this article we will consider three problems: first we will modify a stack in a way that allows us to find the smallest element of the stack",
    "topic": "Data Structure",
    "difficulty": "medium"
  },
  {
    "authorID": 1,
    "title": "Disjoint Set Union",
    "description": "This article discusses the data structure Disjoint Set Union or DSU. Often it is also called Union Find because of its two main operations.",
    "topic": "dsu",
    "difficulty": "medium"
  },
  {
    "authorID": 1,
    "title": "Treap (Cartesian tree)",
    "description": "A treap is a data structure which combines binary tree and binary heap (hence the name: tree + heap  Treap).",
    "topic": "Data Structure",
    "difficulty": "hard"
  },
  {
    "authorID": 3,
    "title": "Fenwick Tree",
    "description": "Fenwick tree was first described in a paper titled \"A new data structure for cumulative frequency tables\" (Peter M. Fenwick, 1994).",
    "topic": "Data Structure",
    "difficulty": "medium"
  },
  {
    "authorID": 3,
    "title": "Sqrt Tree",
    "description": "We cannot answer only the queries that entirely fit in one block. But what if we build the same structure as described above for each block? Yes, we can do it. And we do it recursively, until we reach the block size of  or . Answers for such blocks can be calculated easily in .",
    "topic": "Data Structure",
    "difficulty": "medium"
  },
  {
    "authorID": 3,
    "title": "Randomized Heap",
    "description": "A randomized heap is a heap that, through using randomization, allows to perform all operations in expected logarithmic time. A min heap is a binary tree in which the value of each vertex is less than or equal to the values of its children. Thus the minimum of the tree is always in the root vertex. A max heap can be defined in a similar way: by replacing less with greater",
    "topic": "Data Structure",
    "difficulty": "hard"
  },
  {
    "authorID": 4,
    "title": "Star and bars",
    "description": "Stars and bars is a mathematical technique for solving certain combinatorial problems. It occurs whenever you want to count the number of ways to group identical objects",
    "topic": "Combinatorics",
    "difficulty": "medium"
  },
  {
    "authorID": 2,
    "title": "Bellman-Ford Algorithm",
    "description": "Single source shortest path with negative weight edges\n\nSuppose that we are given a weighted directed graph  with  vertices and  edges, and some specified vertex . You want to find the length of shortest paths from vertex  to every other vertex.\n\nUnlike the Dijkstra algorithm, this algorithm can also be applied to graphs containing negative weight edges . However, if the graph contains a negative cycle, then, clearly, the shortest path to some vertices may not exist (due to the fact that the weight of the shortest path must be equal to minus infinity); however, this algorithm can be modified to signal the presence of a cycle of negative weight, or even deduce this cycle.\n\nThe algorithm bears the name of two American scientists: Richard Bellman and Lester Ford. Ford actually invented this algorithm in 1956 during the study of another mathematical problem, which eventually reduced to a subproblem of finding the shortest paths in the graph, and Ford gave an outline of the algorithm to solve this problem. Bellman in 1958 published an article devoted specifically to the problem of finding the shortest path, and in this article he clearly formulated the algorithm in the form in which it is known to us now.\n\nDescription of the algorithm\nLet us assume that the graph contains no negative weight cycle. The case of presence of a negative weight cycle will be discussed below in a separate section.\n\nWe will create an array of distances , which after execution of the algorithm will contain the answer to the problem. In the beginning we fill it as follows: , and all other elements  equal to infinity .\n\nThe algorithm consists of several phases. Each phase scans through all edges of the graph, and the algorithm tries to produce relaxation along each edge  having weight . Relaxation along the edges is an attempt to improve the value  using value . In fact, it means that we are trying to improve the answer for this vertex using edge  and current response for vertex .\n\nIt is claimed that  phases of the algorithm are sufficient to correctly calculate the lengths of all shortest paths in the graph (again, we believe that the cycles of negative weight do not exist). For unreachable vertices the distance  will remain equal to infinity .\n\nImplementation\nUnlike many other graph algorithms, for Bellman-Ford algorithm, it is more convenient to represent the graph using a single list of all edges (instead of  lists of edges - edges from each vertex). We start the implementation with a structure  for representing the edges. The input to the algorithm are numbers , , list  of edges and the starting vertex . All the vertices are numbered  to .\n\nThe simplest implementation\nThe constant  denotes the number \"infinity\" — it should be selected in such a way that it is greater than all possible path lengths.\n\n\nstruct edge\n{\n    int a, b, cost;\n};\n\nint n, m, v;\nvector<edge> e;\nconst int INF = 1000000000;\n\nvoid solve()\n{\n    vector<int> d (n, INF);\n    d[v] = 0;\n    for (int i=0; i<n-1; ++i)\n        for (int j=0; j<m; ++j)\n            if (d[e[j].a] < INF)\n                d[e[j].b] = min (d[e[j].b], d[e[j].a] + e[j].cost);\n    // display d, for example, on the screen\n}\nThe check if (d[e[j].a] < INF) is needed only if the graph contains negative weight edges: no such verification would result in relaxation from the vertices to which paths have not yet found, and incorrect distance, of the type ,  etc. would appear.\n\nA better implementation\nThis algorithm can be somewhat speeded up: often we already get the answer in a few phases and no useful work is done in remaining phases, just a waste visiting all edges. So, let's keep the flag, to tell whether something changed in the current phase or not, and if any phase, nothing changed, the algorithm can be stopped. (This optimization does not improve the asymptotic behavior, i.e., some graphs will still need all  phases, but significantly accelerates the behavior of the algorithm \"on an average\", i.e., on random graphs.)\n\nWith this optimization, it is generally unnecessary to restrict manually the number of phases of the algorithm to  — the algorithm will stop after the desired number of phases.\n\n\nvoid solve()\n{\n    vector<int> d (n, INF);\n    d[v] = 0;\n    for (;;)\n    {\n        bool any = false;\n\n        for (int j=0; j<m; ++j)\n            if (d[e[j].a] < INF)\n                if (d[e[j].b] > d[e[j].a] + e[j].cost)\n                {\n                    d[e[j].b] = d[e[j].a] + e[j].cost;\n                    any = true;\n                }\n\n        if (!any) break;\n    }\n    // display d, for example, on the screen\n}\nRetrieving Path\nLet us now consider how to modify the algorithm so that it not only finds the length of shortest paths, but also allows to reconstruct the shortest paths.\n\nFor that, let's create another array , where for each vertex we store its \"predecessor\", i.e. the penultimate vertex in the shortest path leading to it. In fact, the shortest path to any vertex  is a shortest path to some vertex , to which we added  at the end of the path.\n\nNote that the algorithm works on the same logic: it assumes that the shortest distance to one vertex is already calculated, and, tries to improve the shortest distance to other vertices from that vertex. Therefore, at the time of improvement we just need to remember , i.e, the vertex from which this improvement has occurred.\n\nFollowing is an implementation of the Bellman-Ford with the retrieval of shortest path to a given node :\n\n\nvoid solve()\n{\n    vector<int> d (n, INF);\n    d[v] = 0;\n    vector<int> p (n, -1);\n\n    for (;;)\n    {\n        bool any = false;\n        for (int j = 0; j < m; ++j)\n            if (d[e[j].a] < INF)\n                if (d[e[j].b] > d[e[j].a] + e[j].cost)\n                {\n                    d[e[j].b] = d[e[j].a] + e[j].cost;\n                    p[e[j].b] = e[j].a;\n                    any = true;\n                }\n        if (!any)  break;\n    }\n\n    if (d[t] == INF)\n        cout << \"No path from \" << v << \" to \" << t << \".\";\n    else\n    {\n        vector<int> path;\n        for (int cur = t; cur != -1; cur = p[cur])\n            path.push_back (cur);\n        reverse (path.begin(), path.end());\n\n        cout << \"Path from \" << v << \" to \" << t << \": \";\n        for (size_t i=0; i<path.size(); ++i)\n            cout << path[i] << ' ';\n    }\n}\nHere starting from the vertex , we go through the predecessors till we reach starting vertex with no predecessor, and store all the vertices in the path in the list . This list is a shortest path from  to , but in reverse order, so we call  function over  and then output the path.\n\nThe proof of the algorithm\nFirst, note that for all unreachable vertices  the algorithm will work correctly, the label  will remain equal to infinity (because the algorithm Bellman-Ford will find some way to all reachable vertices from the start vertex , and relaxation for all other remaining vertices will never happen).\n\nLet us now prove the following assertion: After the execution of  phase, the Bellman-Ford algorithm correctly finds all shortest paths whose number of edges does not exceed .\n\nIn other words, for any vertex  let us denote the  number of edges in the shortest path to it (if there are several such paths, you can take any). According to this statement, the algorithm guarantees that after  phase the shortest path for vertex  will be found.\n\nProof: Consider an arbitrary vertex  to which there is a path from the starting vertex , and consider a shortest path to it . Before the first phase, the shortest path to the vertex  was found correctly. During the first phase, the edge  has been checked by the algorithm, and therefore, the distance to the vertex  was correctly calculated after the first phase. Repeating this statement  times, we see that after  phase the distance to the vertex  gets calculated correctly, which we wanted to prove.\n\nThe last thing to notice is that any shortest path cannot have more than  edges. Therefore, the algorithm sufficiently goes up to the  phase. After that, it is guaranteed that no relaxation will improve the distance to some vertex.\n\nThe case of a negative cycle\nEverywhere above we considered that there is no negative cycle in the graph (precisely, we are interested in a negative cycle that is reachable from the starting vertex , and, for an unreachable cycles nothing in the above algorithm changes). In the presence of a negative cycle(s), there are further complications associated with the fact that distances to all vertices in this cycle, as well as the distances to the vertices reachable from this cycle is not defined — they should be equal to minus infinity .\n\nIt is easy to see that the Bellman-Ford algorithm can endlessly do the relaxation among all vertices of this cycle and the vertices reachable from it. Therefore, if you do not limit the number of phases to , the algorithm will run indefinitely, constantly improving the distance from these vertices.\n\nHence we obtain the criterion for presence of a cycle of negative weights reachable for source vertex : after  phase, if we run algorithm for one more phase, and it performs at least one more relaxation, then the graph contains a negative weight cycle that is reachable from ; otherwise, such a cycle does not exist.\n\nMoreover, if such a cycle is found, the Bellman-Ford algorithm can be modified so that it retrieves this cycle as a sequence of vertices contained in it. For this, it is sufficient to remember the last vertex  for which there was a relaxation in  phase. This vertex will either lie in a negative weight cycle, or is reachable from it. To get the vertices that are guaranteed to lie in a negative cycle, starting from the vertex , pass through to the predecessors  times. Hence we will get the vertex , namely the vertex in the cycle earliest reachable from source. We have to go from this vertex, through the predecessors, until we get back to the same vertex  (and it will happen, because relaxation in a negative weight cycle occur in a circular manner).\n\nImplementation:\n\nvoid solve()\n{\n    vector<int> d (n, INF);\n    d[v] = 0;\n    vector<int> p (n, - 1);\n    int x;\n    for (int i=0; i<n; ++i)\n    {\n        x = -1;\n        for (int j=0; j<m; ++j)\n            if (d[e[j].a] < INF)\n                if (d[e[j].b] > d[e[j].a] + e[j].cost)\n                {\n                    d[e[j].b] = max (-INF, d[e[j].a] + e[j].cost);\n                    p[e[j].b] = e[j].a;\n                    x = e[j].b;\n                }\n    }\n\n    if (x == -1)\n        cout << \"No negative cycle from \" << v;\n    else\n    {\n        int y = x;\n        for (int i=0; i<n; ++i)\n            y = p[y];\n\n        vector<int> path;\n        for (int cur=y; ; cur=p[cur])\n        {\n            path.push_back (cur);\n            if (cur == y && path.size() > 1)\n                break;\n        }\n        reverse (path.begin(), path.end());\n\n        cout << \"Negative cycle: \";\n        for (size_t i=0; i<path.size(); ++i)\n            cout << path[i] << ' ';\n    }\n}\nDue to the presence of a negative cycle, for  iterations of the algorithm, the distances may go far in the negative range (to negative numbers of the order of , where  is the maximum absolute value of any weight in the graph). Hence in the code, we adopted additional measures against the integer overflow as follows:\n\n\nd[e[j].b] = max (-INF, d[e[j].a] + e[j].cost);\nThe above implementation looks for a negative cycle reachable from some starting vertex ; however, the algorithm can be modified to just looking for any negative cycle in the graph. For this we need to put all the distance  to zero and not infinity — as if we are looking for the shortest path from all vertices simultaneously; the validity of the detection of a negative cycle is not affected.\n\nFor more on this topic — see separate article, Finding a negative cycle in the graph.\n\nShortest Path Faster Algorithm (SPFA)\nSPFA is a improvement of the Bellman-Ford algorithm which takes advantage of the fact that not all attempts at relaxation will work. The main idea is to create a queue containing only the vertices that were relaxed but that still could further relax their neighbors. And whenever you can relax some neighbor, you should put him in the queue. This algorithm can also be used to detect negative cycles as the Bellman-Ford.\n\nThe worst case of this algorithm is equal to the  of the Bellman-Ford, but in practice it works much faster and some people claim that it works even in  on average. However be careful, because this algorithm is deterministic and it is easy to create counterexamples that make the algorithm run in .\n\nThere are some care to be taken in the implementation, such as the fact that the algorithm continues forever if there is a negative cycle. To avoid this, it is possible to create a counter that stores how many times a vertex has been relaxed and stop the algorithm as soon as some vertex got relaxed for the -th time. Note, also there is no reason to put a vertex in the queue if it is already in.\n\n\nconst int INF = 1000000000;\nvector<vector<pair<int, int>>> adj;\n\nbool spfa(int s, vector<int>& d) {\n    int n = adj.size();\n    d.assign(n, INF);\n    vector<int> cnt(n, 0);\n    vector<bool> inqueue(n, false);\n    queue<int> q;\n\n    d[s] = 0;\n    q.push(s);\n    inqueue[s] = true;\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        inqueue[v] = false;\n\n        for (auto edge : adj[v]) {\n            int to = edge.first;\n            int len = edge.second;\n\n            if (d[v] + len < d[to]) {\n                d[to] = d[v] + len;\n                if (!inqueue[to]) {\n                    q.push(to);\n                    inqueue[to] = true;\n                    cnt[to]++;\n                    if (cnt[to] > n)\n                        return false;  // negative cycle\n                }\n            }\n        }\n    }\n    return true;\n}",
    "topic": "Graph",
    "difficulty": "medium"
  },
  {
    "name": "simantaturja",
    "email": "simantaturja@gmail",
    "password": "simantaturja12345"
  },
  {
    "name": "Murad Hossen",
    "email": "murad@gmail.com",
    "password": "muradmuradmurad",
    "passwordConfirm": "muradmurad"
  },
  {
    "name": "Tashfiq Ahmed",
    "email": "tashfiq@gmail.com",
    "password": "tashfiqtashfiq",
    "passwordConfirm": "tashfiqtashfiq"
  },
  {
    "name": "Akash Lanard",
    "email": "akash@gmail.com",
    "password": "akashakash",
    "passwordConfirm": "akashakash"
  },
  {
    "name": "Tanima Ahmed",
    "email": "tanima@gmail.com",
    "password": "tanimatanima",
    "passwordConfirm": "tanimatanima"
  },
  {
    "name": "Sajid Ahmed",
    "email": "sajid@gmail.com",
    "password": "sajidsajid",
    "passwordConfirm": "sajidsajid"
  },
  {
    "name": "Saifur",
    "email": "saifur@gmail.com",
    "password": "saifursaifur",
    "passwordConfirm": "saifursaifur"
  },
  {
    "name": "Priyo Ahmed",
    "email": "priyo@gmail.com",
    "password": "priyopriyo",
    "passwordConfirm": "priyopriyo"
  }
]
